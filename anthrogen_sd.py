# A set of helper methods for streamlining the process of generating
#  images for anthropographics using Stable Diffusion.
# wjwillett 2023-07-22



# -*- coding: utf-8 -*-
"""AI-Anthro-StableDiffusion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-ysYWNRFBl2JmVUx009zymyY7zVptkOY

# Pipeline setup and prompt generation helpers
"""

import copy
import pandas as pd
import numpy as np
import os
from google.colab import drive

# Helper to populate a copy of the source template based on a dict of terms
#  assumes that the keys in the terms dictionary match the bracketed ALL_CAPS placeholders
#  in the positive and negative templates. (See Tests below for an example.)
#  Also saves the list of terms and a dash-concatenated version of them to the template.
def populate_template(source_template, terms):
  template = copy.deepcopy(source_template)
  for term in terms.keys():
    template["positive"] = template["positive"].replace("{"+term+"}",terms[term])
    template["negative"] = template["negative"].replace("{"+term+"}",terms[term])
    template["terms"] = terms
    template["key"] = "-".join([term[1] for term in list(terms.items())])
  return template

# Populates templates using data from a dataframe and returns either as a new
#  dataframe or as a copy of the original source dataframe with appended columns
#  assumes that the column names given in "columns" match the bracketed ALL_CAPS
#  placeholders in the templates. Also included dash-concatenated lists of column
#  names and values as a key.
# (See Tests below for a demonstration.)
def generate_prompts_from_dataframe(source_dataframe, template, columns, concat_with_source=True):
  prompt_dataframe = pd.DataFrame(columns=["model_positive_prompt","model_negative_prompt","model_columns","model_key"])
  for index, row in source_dataframe.iterrows():
    # for every row in the source_dataframe, create a new copy of the template to update
    temp_template = copy.deepcopy(template)
    key_parts = []
    # populate the template prompts with data from each of the specified columns
    for term in columns:
      temp_template["positive"] = temp_template["positive"].replace("{{{"+term+"}}}",row[term])
      temp_template["negative"] = temp_template["negative"].replace("{{{"+term+"}}}",row[term])
      key_parts.append(row[term])
    # add a row to the new dataframe
    new_row = pd.DataFrame({"model_positive_prompt": temp_template["positive"],
                  "model_negative_prompt":temp_template["negative"],
                  "model_columns": "-".join(columns),
                  "model_key": "-".join(key_parts)},index=[index])
    prompt_dataframe = pd.concat([prompt_dataframe,new_row])
  if concat_with_source:
     prompt_dataframe = pd.concat([source_dataframe,prompt_dataframe],axis=1)
  return prompt_dataframe

# Use the provided pipeline to generate an image for each row in a prompt dataframe.
#  Optionally saves images and a CSV of the dataframe either locally in Colab or GDrive.
def generate_images(pipe, prompt_dataframe, save_to_gdrive=False, save_to_colab=True,
                    gdrive_output_folder="", colab_output_folder="generated_images",
                    positive_prompt_col="model_positive_prompt", negative_prompt_col="model_negative_prompt",
                    key_col="model_key"):

  create_output_folders(save_to_gdrive,save_to_colab,gdrive_output_folder,colab_output_folder)

  print("\nGenerating...\n")
  # Generate and save images
  for index, row in prompt_dataframe.iterrows():
    print(str(index) + ". " + row[key_col])
    result = pipe(row[positive_prompt_col], negative_prompt=row[negative_prompt_col]).images[0]
    display(result)
    if save_to_colab:
      result.save(f'{colab_output_folder}/{row[key_col]}.png')
    if save_to_gdrive:
      result.save(f'{gdrive_output_folder}/{row[key_col]}.png')

# Save a dataframe to CSV, locally on colab and/or GDrive
def save_dataframe(prompt_dataframe, filename="dataframe.csv", save_to_gdrive=False, save_to_colab=True,
                    gdrive_output_folder="", colab_output_folder="generated_images"):

  create_output_folders(save_to_gdrive,save_to_colab,gdrive_output_folder,colab_output_folder)

  if save_to_colab:
    prompt_dataframe.to_csv(colab_output_folder + "/" + filename)
    print("Saved " + colab_output_folder + "/" + filename)
  if save_to_gdrive:
    prompt_dataframe.to_csv(gdrive_output_folder + "/" + filename)
    print("Saved " + gdrive_output_folder + "/" + filename)

# Helper that generates a dataframe containing all combinations of terms from an
#  initial term dictionary.
def generate_term_dataframe_from_dict(term_dict):
  term_combinations = []
  for age in term_dict["ages"]:
    for race in term_dict["races"]:
      for gender in term_dict["genders"]:
        term_combinations.append({"Gender":gender,"Race":race,"Age":age})
  return pd.DataFrame.from_records(term_combinations)

# Helper to create output folders locally on colab and/or GDrive.
def create_output_folders(save_to_gdrive=False, save_to_colab=True,
                    gdrive_output_folder="", colab_output_folder="generated_images"):
  # local spot to save all of the files
  if save_to_colab:
    try:
      os.mkdir(colab_output_folder)
    except FileExistsError as ex:
      pass

  # GDrive to save all of the files
  if save_to_gdrive:
    drive.mount('/content/drive/')
    try:
      os.mkdir(gdrive_output_folder)
    except FileExistsError as ex:
      pass

