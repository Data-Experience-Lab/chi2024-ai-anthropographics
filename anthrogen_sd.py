# A set of helper methods for streamlining the process of generating
#  images for anthropographics using Stable Diffusion.
# wjwillett 2023-07-22



# -*- coding: utf-8 -*-
"""anthrogen_sd.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-ysYWNRFBl2JmVUx009zymyY7zVptkOY

A set of helper methods for streamlining the process of generating images for anthropographics using Stable Diffusion.

# Pipeline setup and prompt generation helpers
"""

import copy
import pandas as pd
import numpy as np
import math
import os
import re
from google.colab import drive

# Populates templates using data from a dataframe and returns either as a new
#  dataframe or as a copy of the original source dataframe with appended columns.
#  Assumes that the column names in the dataframe match the triple-bracketed
#  variables in the templates. Also included dash-concatenated lists of column
#  names and values as a key.
# (See Tests below for a demonstration.)
def generate_prompts_from_dataframe(source_dataframe, template, concat_with_source=True):
  prompt_dataframe = pd.DataFrame(columns=["model_positive_prompt","model_negative_prompt","model_columns","model_key"])
  # get the column names referenced in the the prompts
  pos_columns = re.findall("{{{(\w+)}}}",template["positive"])
  neg_columns = re.findall("{{{(\w+)}}}",template["negative"])

  # for every row in the source_dataframe
  for index, row in source_dataframe.iterrows():
    # create a new copy of the template to update
    temp_template = copy.deepcopy(template)
    key_parts = []
    # populate the template prompts with data from each of the specified columns
    for term in pos_columns:
      temp_template["positive"] = temp_template["positive"].replace("{{{"+term+"}}}",row[term])
      key_parts.append(row[term])
    for term in neg_columns:
      temp_template["negative"] = temp_template["negative"].replace("{{{"+term+"}}}",row[term])
      key_parts.append(row[term])
    # add a row to the new dataframe
    new_row = pd.DataFrame({"model_positive_prompt": temp_template["positive"],
                  "model_negative_prompt":temp_template["negative"],
                  "model_columns": "-".join(pos_columns+neg_columns),
                  "model_key": "-".join(key_parts)},index=[index])
    prompt_dataframe = pd.concat([prompt_dataframe,new_row])
  # when done, concatenate the zero-padded index to the beginning of the key
  prompt_dataframe["index_col"] = prompt_dataframe.index
  num_digits = int(math.log10(prompt_dataframe.shape[0]))+1
  prompt_dataframe["model_key"] = prompt_dataframe.apply(
      lambda r: f'{str(r["index_col"]).zfill(num_digits)}_{r["model_key"]}',1)
  if concat_with_source:
     prompt_dataframe = pd.concat([source_dataframe,prompt_dataframe],axis=1)
  prompt_dataframe.sort_values(by=["model_key"],inplace=True)
  return prompt_dataframe

# Use the provided pipeline to generate an image for each row in a prompt dataframe.
#  Optionally saves images and a CSV of the dataframe either locally in Colab or GDrive.
def generate_images(pipe, prompt_dataframe, save_to_gdrive=False, save_to_colab=True,
                    gdrive_output_folder="", colab_output_folder="generated_images",
                    positive_prompt_col="model_positive_prompt", negative_prompt_col="model_negative_prompt",
                    key_col="model_key"):

  create_output_folders(save_to_gdrive,save_to_colab,gdrive_output_folder,colab_output_folder)

  print("\nGenerating...\n")
  # Generate and save images
  for index, row in prompt_dataframe.iterrows():
    print(str(index) + ". " + row[key_col])
    result = pipe(row[positive_prompt_col], negative_prompt=row[negative_prompt_col]).images[0]
    display(result)
    if save_to_colab:
      result.save(f'{colab_output_folder}/{row[key_col]}.png')
    if save_to_gdrive:
      result.save(f'{gdrive_output_folder}/{row[key_col]}.png')

# Save a dataframe to CSV, locally on colab and/or GDrive
def save_dataframe(prompt_dataframe, filename="dataframe.csv", save_to_gdrive=False, save_to_colab=True,
                    gdrive_output_folder="", colab_output_folder="generated_images"):

  create_output_folders(save_to_gdrive,save_to_colab,gdrive_output_folder,colab_output_folder)

  if save_to_colab:
    prompt_dataframe.to_csv(colab_output_folder + "/" + filename)
    print("Saved " + colab_output_folder + "/" + filename)
  if save_to_gdrive:
    prompt_dataframe.to_csv(gdrive_output_folder + "/" + filename)
    print("Saved " + gdrive_output_folder + "/" + filename)

# Helper that generates a dataframe containing all combinations of terms from an
#  initial term dictionary.
def generate_term_dataframe_from_dict(term_dict):
  term_combinations = []
  for age in term_dict["ages"]:
    for race in term_dict["races"]:
      for gender in term_dict["genders"]:
        term_combinations.append({"Gender":gender,"Race":race,"Age":age})
  return pd.DataFrame.from_records(term_combinations)

# Helper to create output folders locally on colab and/or GDrive.
def create_output_folders(save_to_gdrive=False, save_to_colab=True,
                    gdrive_output_folder="", colab_output_folder="generated_images"):
  # local spot to save all of the files
  if save_to_colab:
    try:
      os.mkdir(colab_output_folder)
    except FileExistsError as ex:
      pass

  # GDrive to save all of the files
  if save_to_gdrive:
    drive.mount('/content/drive/')
    try:
      os.mkdir(gdrive_output_folder)
    except FileExistsError as ex:
      pass
